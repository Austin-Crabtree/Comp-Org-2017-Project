$date
	Sat Apr 22 15:47:44 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ID_tb $end
$scope module test $end
$var wire 1 ! Clk $end
$var wire 32 " In_IR [31:0] $end
$var wire 32 # In_PC [31:0] $end
$var wire 5 $ In_Rd [4:0] $end
$var wire 1 % In_RegWrite $end
$var wire 32 & In_WriteData [31:0] $end
$var wire 1 ' OutJump $end
$var wire 1 ( OutPCSrc $end
$var wire 1 ) RegWrite $end
$var wire 2 * WBControl [1:0] $end
$var wire 32 + SE [31:0] $end
$var wire 1 , RegDst $end
$var wire 32 - OutJumpPC [31:0] $end
$var wire 32 . OutBranchPC [31:0] $end
$var wire 1 / MemWrite $end
$var wire 1 0 MemToReg $end
$var wire 1 1 MemRead $end
$var wire 2 2 MEMControl [1:0] $end
$var wire 1 3 Jump $end
$var wire 3 4 Funct [2:0] $end
$var wire 4 5 EXControl [3:0] $end
$var wire 32 6 DataBTmp [31:0] $end
$var wire 32 7 DataATmp [31:0] $end
$var wire 1 8 Bne $end
$var wire 1 9 Beq $end
$var wire 1 : ALUSrc $end
$var wire 2 ; ALUOp [1:0] $end
$var reg 32 < OutDataA [31:0] $end
$var reg 32 = OutDataB [31:0] $end
$var reg 4 > OutEXControl [3:0] $end
$var reg 3 ? OutFunct [2:0] $end
$var reg 2 @ OutMEMControl [1:0] $end
$var reg 5 A OutRd [4:0] $end
$var reg 5 B OutRs [4:0] $end
$var reg 5 C OutRt [4:0] $end
$var reg 32 D OutSE [31:0] $end
$var reg 2 E OutWBControl [1:0] $end
$scope module Ctrl $end
$var wire 6 F Funct [5:0] $end
$var wire 6 G opcode [5:0] $end
$var reg 3 H ALUControl [2:0] $end
$var reg 2 I ALUop [1:0] $end
$var reg 1 J ALUsrc $end
$var reg 1 1 Beq $end
$var reg 1 9 Bne $end
$var reg 1 8 Jump $end
$var reg 1 / MemRead $end
$var reg 1 3 MemToReg $end
$var reg 1 , MemWrite $end
$var reg 1 K RFormat $end
$var reg 1 L RegDst $end
$var reg 1 0 RegWrite $end
$var reg 1 M beq $end
$var reg 1 N bne $end
$var reg 1 O jmp $end
$var reg 1 P lw $end
$var reg 1 Q sw $end
$upscope $end
$scope module Reg $end
$var wire 1 ! Clk $end
$var wire 32 R ReadData1 [31:0] $end
$var wire 32 S ReadData2 [31:0] $end
$var wire 5 T ReadRegister1 [4:0] $end
$var wire 5 U ReadRegister2 [4:0] $end
$var wire 1 % RegWrite $end
$var wire 32 V WriteData [31:0] $end
$var wire 5 W WriteRegister [4:0] $end
$upscope $end
$scope module Sign $end
$var wire 16 X a [15:0] $end
$var reg 32 Y result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100100000x00000 Y
b100100000x00000 X
b1001 W
b1111 V
b1000 U
b10 T
bx S
bx R
0Q
0P
0O
0N
0M
1L
1K
0J
b10 I
b1x H
b0 G
b0z F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
b1 ;
0:
09
08
bx 7
bx 6
b10 5
b1x 4
03
b0 2
01
10
0/
bx .
b10010000100100000x0000000 -
0,
b100100000x00000 +
b1z *
z)
0(
0'
b1111 &
0%
b1001 $
b0 #
b10010000100100000x00000 "
1!
$end
#10
b1x ?
b1z E
b0 @
b10 >
b1001 A
b1000 C
b10 B
b100100000x00000 D
0!
#20
1!
#30
0!
#40
1!
